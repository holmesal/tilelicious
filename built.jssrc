'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
//import latLngToTileXY from './tileUtils';

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = false; // turns on tile box renderings
var basemapOpacity = 0.05;

// Constants
// should this change per image size?
var BORDER = 50;
// Maximum static map size, from mapbox
var MAX_SIZE = {
    w: 256,
    h: 256
};

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = function StravaMap(center, z, size) {
    _classCallCheck(this, StravaMap);

    // Get the dims for this paper size
    this.dims = getDims(size);
};

var dims = (0, _sizes.getSize)(size);

// First, get the bounds of the viewport, using:
//   * the pixel dimensions of the mask
//   * the geographic center
//   * the zoom level
var bbox = _geoViewport2.default.bounds(center, z, [dims.w, dims.h]);

// Next, find the tile extent that covers bbox
var xyzBounds = sm.xyz(bbox, z);

// Find the geographic bbox of the above tiles
var tileBbox = sm.bbox(xyzBounds.minX, xyzBounds.minY, z);

// Get pixel position for each bounding box
var bboxPx = sm.px([bbox[0], bbox[3]], z);
var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

// Get the vector from the corner of the tile bbox to the corner of the view bbox
var offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

console.log('bbox', bbox);
console.log('xyzBounds', xyzBounds);
console.log('tileBbox', tileBbox);
console.log('pixels', bboxPx, tilePx);
console.log('offset', offset);

//return false;

// W-S-E-N
//let bbox = [
//    -122.347269,
//    37.77621,
//    -122.217321,
//    37.837513
//];

var canvas = new _canvas2.default(dims.w, dims.h);

var ctx = canvas.getContext('2d');

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

// Draw the white background
var bg = function bg(color) {
    ctx.rect(0, 0, dims.w, dims.h);
    ctx.fillStyle = color;
    ctx.fill();
};

// Render the mapbox tiles
var render = function render() {
    // Render out to a png
    var out = _fs2.default.createWriteStream(__dirname + '/test.png');
    var stream = canvas.pngStream();

    stream.on('data', function (chunk) {
        out.write(chunk);
    });

    stream.on('end', function () {
        console.log('saved png');
    });
};

var fetchMapboxImages = function fetchMapboxImages() {
    console.log('bbox', bbox);

    // How many images should we fetch from mapbox?
    var numCols = Math.ceil(dims.w / MAX_SIZE.w);
    var numRows = Math.ceil(dims.h / MAX_SIZE.h);
    // How much lat/lng should each image be responsible for?
    var intervals = {
        lon: (bbox[2] - bbox[0]) / numCols,
        lat: (bbox[3] - bbox[1]) / numRows,
        pixelsX: dims.w / numCols,
        pixelsY: dims.h / numRows
    };
    // Request one image for each range
    console.log('fetching ' + numCols + ' x ' + numRows + ' images');
    for (var x = 0; x < numCols; x++) {
        for (var y = 0; y < numRows; y++) {
            //W-S-E-N
            var edges = [bbox[0] + intervals.lon * x, //minlon
            bbox[1] + intervals.lat * y, bbox[0] + intervals.lon * (x + 1), bbox[1] + intervals.lat * (y + 1)];
            var _z = 14;
            var _xyzBounds = sm.xyz(edges, _z);
            console.log(_xyzBounds);
            // Pixel bounds
            var pixels = [Math.round(intervals.pixelsX * x), Math.round(intervals.pixelsY * y), Math.round(intervals.pixelsX * (x + 1)), Math.round(intervals.pixelsY * (y + 1))];
            //let center = [
            //    (edges[2] + edges[0]) / 2,
            //    (edges[3] + edges[1]) / 2
            //];
            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
            //let size = [
            //    pixels[2] - pixels[0],
            //    pixels[3] - pixels[1]
            //];
            //// Calculate center and zoom
            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
            //console.log(x, y);
            //console.log('bounds', bounds);
            //console.log(pixels);
            //console.log(size);
            //console.log('viewport', viewport);
            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
            //console.log('\n\n --- \n\n');
            //
            //let pos = [
            //    MAX_SIZE.w * x,
            //    MAX_SIZE.h * y
            //];
            //
            var mapboxTile = new ImageFetcher(_xyzBounds.minX, _xyzBounds.minY, _z);
            break;
        }
        break;
    }
};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var relX = x - tileBounds.minX;
            var relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this.relX * size;
                    var pY = _this.relY * size;
                    console.log('tile [' + renderCount + '/' + _this.count + '] ... drawing ' + _this.relX + ', ' + _this.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

bg('#202020');
tileThings();
//vectorThings();
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};
var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
//import latLngToTileXY from './tileUtils';

var _canvas = require('canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _geoViewport = require('geo-viewport');

var _geoViewport2 = _interopRequireDefault(_geoViewport);

var _sphericalmercator = require('sphericalmercator');

var _sphericalmercator2 = _interopRequireDefault(_sphericalmercator);

var _mapnik = require('mapnik');

var _mapnik2 = _interopRequireDefault(_mapnik);

var _togeojson = require('togeojson');

var _togeojson2 = _interopRequireDefault(_togeojson);

var _geojsonMapnikify = require('geojson-mapnikify');

var _geojsonMapnikify2 = _interopRequireDefault(_geojsonMapnikify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sizes = require('./sizes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var sm = new _sphericalmercator2.default({ size: 256 });

// Knobs to turn
var debug = true; // turns on tile box renderings
var basemapOpacity = 1;

// Constants
// should this change per image size?
var BORDER = 50;
var MAPBOX_ACCESS_TOKEN = 'pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
// Maximum static map size, from mapbox
var TILE_SIZE = 256;

// TODO - make these inputs
var size = 'a4';
var z = 15;
var center = [-122.2708, 37.8044]; // lon, lat

var StravaMap = (function () {
    function StravaMap(center, z, size, mapid) {
        var _this = this;

        _classCallCheck(this, StravaMap);

        this.center = center;
        this.z = z;
        this.size = size;
        this.mapid = mapid;

        // Get the dims for this paper size
        this.dims = (0, _sizes.getDims)(size);

        // Init the canvas
        this.initCanvas();

        // Initialize geo extents
        this.initGeo(center, z, this.dims);

        // Fetch ze images!
        this.fetchMapboxImages().then(function () {
            console.info('done fetching images!');
            _this.renderToFile();
        }).catch(function (err) {
            console.error(err);
        });
    }

    _createClass(StravaMap, [{
        key: 'initGeo',
        value: function initGeo(center, z, dims) {
            // First, get the bounds of the viewport, using:
            //   * the pixel dimensions of the mask
            //   * the geographic center
            //   * the zoom level
            // W-S-E-N
            var bbox = _geoViewport2.default.bounds(center, z, [this.dims.w, this.dims.h]);

            // Next, find the tile extent that covers bbox
            this.xyzBounds = sm.xyz(bbox, z);

            // Find the geographic bbox of the above tiles
            var tileBbox = sm.bbox(this.xyzBounds.minX, this.xyzBounds.minY, z);

            // Get pixel position for each bounding box
            var bboxPx = sm.px([bbox[0], bbox[3]], z);
            var tilePx = sm.px([tileBbox[0], tileBbox[3]], z);

            // Get the vector from the corner of the tile bbox to the corner of the view bbox
            this.offset = [bboxPx[0] - tilePx[0], bboxPx[1] - tilePx[1]];

            if (debug) {
                console.log('.....bbox.....\n', bbox);
                console.log('.....xyzBounds.....\n', this.xyzBounds);
                console.log('.....tileBbox.....\n', tileBbox);
                console.log('.....pixels.....\n', bboxPx, tilePx);
                console.log('.....offset.....\n', this.offset);
            }
        }
    }, {
        key: 'initCanvas',
        value: function initCanvas() {
            this.canvas = new _canvas2.default(this.dims.w, this.dims.h);
            this.ctx = this.canvas.getContext('2d');
        }
    }, {
        key: 'drawBackground',
        value: function drawBackground(color) {
            this.ctx.rect(0, 0, this.dims.w, this.dims.h);
            this.ctx.fillStyle = color;
            this.ctx.fill();
        }
    }, {
        key: 'renderToFile',
        value: function renderToFile() {
            // Render out to a png
            var out = _fs2.default.createWriteStream(__dirname + '/test.png');
            var stream = this.canvas.pngStream();

            stream.on('data', function (chunk) {
                out.write(chunk);
            });

            stream.on('end', function () {
                console.log('saved png');
            });
        }
    }, {
        key: 'fetchMapboxImages',
        value: function fetchMapboxImages() {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                // Render count starts off at 0
                _this2.renderCount = 0;

                // Calculate the tile x and y ranges for the current bounding box
                var tileBounds = _this2.xyzBounds;
                // Count the tiles
                var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
                var ic = 0;
                var promises = [];
                console.info('fetching ' + count);
                for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
                    var _loop = function _loop(y) {
                        var relX = x - tileBounds.minX;
                        var relY = y - tileBounds.minY;
                        //if (debug) console.info(`fetching ${x}, ${y}`);

                        //let tile = new ImageFetcher(x, y, z, relX, relY, ic, count);
                        var tilePromise = _this2.fetchImage(x, y, z);
                        promises.push(tilePromise);
                        tilePromise.then(function (tileBuffer) {
                            // Target pixels
                            var pX = relX * TILE_SIZE;
                            var pY = relY * TILE_SIZE;

                            // Log
                            renderCount++;
                            console.log('tile [' + renderCount + '/' + count + '] ... drawing ' + relX + ', ' + relY + ' @ ' + pX + ' [+ ' + _this2.offset[0] + '], ' + pY + ' [+' + _this2.offset[1] + ']');

                            // Adjust by corner offset and render
                            _this2.renderTile(tileBuffer, pX - _this2.offset[0], pY - _this2.offset[1]);

                            // Doneskis
                            resolve();
                        }).catch(function (err) {
                            console.error(err);throw new Error(err);
                        });
                    };

                    for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
                        _loop(y);
                    }
                }
                Promise.all(promises).then(function () {
                    resolve();
                }).catch(function (err) {
                    reject(err);
                });
            });
        }
    }, {
        key: 'fetchImage',
        value: function fetchImage(x, y, z) {
            var _this3 = this;

            return new Promise(function (resolve, reject) {
                // Build the URL
                var url = 'https://api.mapbox.com/v4/' + _this3.mapid + '/' + z + '/' + x + '/' + y + '.png?access_token=' + MAPBOX_ACCESS_TOKEN;
                //if (debug) console.info(url);

                // Make the request
                _superagent2.default.get(url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                        reject(err);
                    } else {
                        resolve(res.body);
                    }
                });
            });
        }
    }, {
        key: 'renderTile',
        value: function renderTile(tileBuffer, x, y) {
            console.info(x, y);
            // Create a new image
            var img = new _canvas.Image();
            img.src = tileBuffer;
            // Fade the basemap, if needed
            this.ctx.globalAlpha = basemapOpacity;
            // Draw
            this.ctx.drawImage(img, x, y);
            // Reset opacity
            this.ctx.globalAlpha = 1;
            // If debugging, stroke tile
            if (debug) {
                this.ctx.rect(x, y, TILE_SIZE, TILE_SIZE);
                this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                this.ctx.stroke();
            }
        }
    }]);

    return StravaMap;
})();

//ctx.font = '10px Arial';
//ctx.rotate(.1);
//ctx.fillText("Awesome!", 0, 100);

//var te = ctx.measureText('Awesome!');
//ctx.strokeStyle = 'rgba(0,0,0,0.5)';
//ctx.beginPath();
//ctx.lineTo(50, 102);
//ctx.lineTo(50 + te.width, 102);
//ctx.stroke();

//let fetchMapboxImages = () => {
//    console.log('bbox', bbox);
//
//    // How many images should we fetch from mapbox?
//    let numCols = Math.ceil(dims.w / MAX_SIZE.w);
//    let numRows = Math.ceil(dims.h / MAX_SIZE.h);
//    // How much lat/lng should each image be responsible for?
//    let intervals = {
//        lon: (bbox[2] - bbox[0]) / numCols,
//        lat: (bbox[3] - bbox[1]) / numRows,
//        pixelsX: dims.w / numCols,
//        pixelsY: dims.h / numRows
//    };
//    // Request one image for each range
//    console.log(`fetching ${numCols} x ${numRows} images`)
//    for (let x = 0; x < numCols; x++) {
//        for (let y = 0; y < numRows; y++) {
//             //W-S-E-N
//            let edges = [
//                bbox[0] + intervals.lon * x, //minlon
//                bbox[1] + intervals.lat * y,
//                bbox[0] + intervals.lon * (x + 1),
//                bbox[1] + intervals.lat * (y + 1)
//            ];
//            let z = 14;
//            let xyzBounds = sm.xyz(edges, z);
//            console.log(xyzBounds);
//            // Pixel bounds
//            let pixels = [
//                Math.round(intervals.pixelsX * x),
//                Math.round(intervals.pixelsY * y),
//                Math.round(intervals.pixelsX * (x + 1)),
//                Math.round(intervals.pixelsY * (y + 1))
//            ];
//            //let center = [
//            //    (edges[2] + edges[0]) / 2,
//            //    (edges[3] + edges[1]) / 2
//            //];
//            //let bounds = geoViewport.bounds(center, 14, [MAX_SIZE.w, MAX_SIZE.h]);
//            //let size = [
//            //    pixels[2] - pixels[0],
//            //    pixels[3] - pixels[1]
//            //];
//            //// Calculate center and zoom
//            //let viewport = geoViewport.viewport(bounds, [MAX_SIZE.w, MAX_SIZE.h]);
//            //console.log(x, y);
//            //console.log('bounds', bounds);
//            //console.log(pixels);
//            //console.log(size);
//            //console.log('viewport', viewport);
//            //console.log('recomputed bounds', geoViewport.bounds(viewport.center, viewport.zoom, [dims.w, dims.h]))
//            //console.log('\n\n --- \n\n');
//            //
//            //let pos = [
//            //    MAX_SIZE.w * x,
//            //    MAX_SIZE.h * y
//            //];
//            //
//            let mapboxTile = new ImageFetcher(xyzBounds.minX, xyzBounds.minY, z);
//            break;
//        }
//        break;
//    }
//};

var tileThings = function tileThings() {
    ctx.globalAlpha = basemapOpacity;
    var tileBounds = sm.xyz(bbox, z);
    console.log(tileBounds);
    var count = (tileBounds.maxX - tileBounds.minX + 1) * (tileBounds.maxY - tileBounds.minY + 1);
    var ic = 0;
    var promises = [];
    for (var x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (var y = tileBounds.minY; y <= tileBounds.maxY; y++) {
            var _relX = x - tileBounds.minX;
            var _relY = y - tileBounds.minY;
            //console.log(`tile [${ic}/${count}]`);
            var tile = new ImageFetcher(x, y, z, _relX, _relY, ic, count);
            var tilePromise = tile.fetchImage();
            promises.push(tilePromise);
        }
    }
    Promise.all(promises).then(function () {
        render();
        ctx.globalAlpha = 1;
        vectorThings();
    });
};

var renderCount = 0;

var ImageFetcher = (function () {
    function ImageFetcher(x, y, z, relX, relY, ic, count) {
        _classCallCheck(this, ImageFetcher);

        this.count = count;
        this.relX = relX;
        this.relY = relY;
        //console.info('rendering tile at ' + pos)
        //console.info(viewport)
        //this.dims = dims;
        //let pos = [0,0];
        //let url = `https://api.mapbox.com/v4/mapbox.streets/${viewport.center[0]},${viewport.center[1]},${viewport.zoom}/${size[0]}x${size[1]}.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ`;
        this.url = 'https://api.mapbox.com/v4/mapbox.streets/' + z + '/' + x + '/' + y + '.png?access_token=pk.eyJ1Ijoic2lyYWxvbnNvIiwiYSI6IkEwdTNZcG8ifQ.Nunkow8Nopb-zUFDlvqciQ';
        //console.log(url);
        //this.fetchImage(url, relX, relY);
    }

    _createClass(ImageFetcher, [{
        key: 'fetchImage',
        value: function fetchImage() {
            var _this4 = this;

            return new Promise(function (resolve, reject) {
                _superagent2.default.get(_this4.url).end(function (err, res) {
                    if (err) {
                        console.error(err);
                    }
                    var size = 256;
                    renderCount++;
                    var pX = _this4.relX * size;
                    var pY = _this4.relY * size;
                    console.log('tile [' + renderCount + '/' + _this4.count + '] ... drawing ' + _this4.relX + ', ' + _this4.relY + ' @ ' + pX + ', ' + pY);
                    var img = new _canvas.Image();
                    img.src = res.body;
                    // this shifts thing to the proper location
                    //ctx.drawImage(img, pX - 200, pY - 80);

                    ctx.drawImage(img, pX - offset[0], pY - offset[1]);

                    if (debug) {
                        ctx.rect(pX - offset[0], pY - offset[1], size, size);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    }
                    resolve();
                    //ctx.drawImage(img, 0, 0, 100, 100);
                    //    //img = new Image;
                    //    img.src = canvas.toBuffer();
                    //    ctx.drawImage(img, 100, 100, 50, 50);
                    //    ctx.drawImage(img, 200, 100, 50, 50);
                });
            });
        }
    }]);

    return ImageFetcher;
})();

var vectorThings = function vectorThings() {
    _mapnik2.default.register_default_fonts();
    _mapnik2.default.register_default_input_plugins();
    var map = new _mapnik2.default.Map(dims.w, dims.h);
    ctx.globalAlpha = 1;

    //map.aspect_fix_mode = 'SHRINK_CANVAS';
    // styles
    //map.loadSync('data/stylesheet.xml');
    //map.loadSync('data/stylesheet.xml');

    var geojson = require('./data/1.json');
    //let style = {
    //    stroke: 'red',
    //    fill: 'red',
    //    'stroke-width': 0.3
    //};
    //geojson.stroke = 'red';
    // https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
    _lodash2.default.assign(geojson.features[0].properties, {
        stroke: '#FFFFFF',
        'stroke-width': 1,
        'stroke-opacity': 0.5
    });
    //console.info(geojson.features[0])
    //geojson.features[0].properties = style;
    //geojson.properties.stroke = 'blue';
    //console.info(geojson.features[0])
    //console.log(geojson)
    var xml = (0, _geojsonMapnikify2.default)(geojson, false, function (err, xml) {
        //console.log(xml);
        map.fromString(xml, {}, function (err, map) {
            //console.log('good')
            //let bounds = mercator.bbox(0,0,0, false, "900913");
            //console.log(map)
            //map.zoomAll();
            //console.log(map)
            // convert to mercator and zoom here
            var bounds = sm.convert(bbox, '900913');
            map.zoomToBox(bounds);
            // render the image
            var im = new _mapnik2.default.Image(dims.w, dims.h);
            //map.renderFileSync('./mapnik.png');
            map.render(im, function (err, im) {
                im.encode('png', function (err, buffer) {
                    console.info(buffer);
                    var img = new _canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, 0, 0);
                    render();
                });
            });
        });
    });

    //let l = new mapnik.Layer('rides');
    //l.datasource = new mapnik.Datasource({type:'geojson',file:'data/1.json'});
    //map.add_layer(l);
};

//ctx.globalAlpha = basemapOpacity;
//bg('#202020');
//tileThings();
////vectorThings();

//bg('#202020');
//tileThings();
//vectorThings();

var map = new StravaMap(center, z, size, 'mapbox.streets');
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var sizes = exports.sizes = {
    a4: {
        w: 3508,
        h: 2480
    }
};

var getDims = exports.getDims = function getDims(size) {
    if (sizes[size]) {
        return sizes[size];
    } else {
        throw new Error('we don\'t have paper in that size....');
    }
};
